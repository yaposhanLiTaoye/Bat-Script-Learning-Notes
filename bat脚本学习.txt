【第一章  杂项】
输出空行   echo=

echo的开关。echo有两种状态，打开和关闭。这里说的是是否开启回显当前所执行的命令。默认情况下，开关是打开的。
因此我们会在cmd一条语句执行效果之前看到该语句本身，就好像你把语句敲在命令行里一样。如果我们需要关闭这个开关，有两种方式，
一种是全局性的，即在脚本一开始就添加语句@echo off，还有一种是局部性的，即在不需要输出命令本身的echo语句之前加@

if 在比较字符串时可以添加选项/i让它大小写不敏感

注释：bat脚本有两种注释方式，一种是REM，另一种是::，后者的原理是:表示一个标签（可以用goto或call来跳转到一个标签），因为任何命令后
接:都是无效的，所以::xxx就成了一个永远无法被引用的标签，于是其作用就相当于注释了。但我们还是建议尽量使用REM，因为使用后者有时会带来
bug，笔者就曾因为在一个if语句的括号里加了一个::xxx的注释，导致运行一直报错调试了将近两个小时，最后还是同事陈杭定位出来了。可谓是惨痛
教训了。比如如下代码就会报错
        set str=lihaitao
        if %str:~0,2% == li (
            :: we remove the first name
            echo yes, he really has the first name li
            :: hhh
            set str=%str:~2%
            ::sss
        )
原因在于最后一行注释，或许是打乱了括号匹配规则。总之尽量不要用::去注释，除非你有十足的把握，那就另说。

当前工作目录（cmd所在目录）    %cd%
脚本所在目录                   %~dp0

在命令notepad a.txt前加start可以打开文件后直接返回到bat脚本的下一句

在bat脚本中运行powershell命令时，有时候遇到有双引号不好处理的时候，可以采取如下方式
echo  command  | powershell -c -

【第二章  字符串】
%var:~a[,n]%  从第a位往后最多截取n个字符，若不指定参数n则截取到最后一位

%var:x=y%  把var字符串中的x替换成y，如果y缺失，则表示删除

如果字符串中由特殊字符，比如&，此时需要用双引号括起来，不然会被解释成多条命令，在赋值时，需使用如下方式
set "bianliang=%str%"

【第三章  变量引用与延迟赋值】
    
    set a=hhh
    echo %a%

以上两句，在执行到echo %a%时，首先将%a%替换成hhh，再执行，相当于c语言的宏定义先预编译一遍。这一点在echo打开的状态下可以很清楚的看到。

需要注意的是，bat脚本在执行的时候是一句一句执行的，而一个变量的赋值只有当赋值动作所在的语句结束之后才会生效。
这一机制可能会导致一些初学者疑惑的地方，比如下面代码段

    set /a a=1
    if "abc" == "abc" (
        set /a a=2
        echo Now a = %a%
    )

初学者或许会以为输出是
        Now a = 2
但其实不是，运行结果为
        Now a = 1

这里其实需要注意的是if语句连同后面的括号部分构成的仅仅是一条语句，也就是说执行这一条语句的时候，cmd首先将if 语句中的%a%替换为当前值，
也就是上一条语句起作用之后的值1，因此实际上cmd执行的是
    set /a a=1
    if "abc" == "abc" (
        set /a a=2
        echo Now a = 1
    )
这就解释了为什么输出的结果会是之前的1了。我们可以在if语句后输出一下a，就能看到a的值变成了2，因为整个if语句已经执行完了。

    那如果我们需要获取一条语句中变量当前实际的值，应该怎么办呢？答案很简单，就是在一开始设置延时扩展，即使用语句
        setlocal enabledelayedexpansion
并在后续需要使用即时值的地方用!var!的形式指代。注意，用感叹号括起来的变量只有在开启了延时扩展才是指引用该变量，在没有开启延时扩展的
情况下单纯表示!字符本身。

扩展：结合前一章字符串截取的知识，我们知道截取字符串第a位后的n位可以用%var:~a,n%表示，注意这里需要a,n是数字。那如何将a和n替换成
可以变化的变量以方便我们对字符串进行处理呢？首先我们需要使用宏定义将a,n处的变量替换为相应的数值，再进行截取。也就是说，里面的起始值a
和截取长度n需要用%括起变量表示，比如
    set str=whenIwasyoung
    set a=1
    set n=3
    echo %str:~%a%,%n%%
以上代码是否可行呢？这里我们可以同样在开启echo的情况下看它的执行情况。可以看到在执行到第4句的时候，其实执行的是
    echo whenIwasyoungan%
不难看出，在进行宏替换时，系统首先替换了%str:~%，也就是str所代表的字符串本身；接着是字符a；接着是%,%，由于没这个变量，所以为空；接着
是字符n;最后的%%在字符串表示字符%本身。故此，我们不能用这种形式来达到我们所希望的效果。结合本章所说的延迟变量扩展，不难想到可以用!括起
变量str，即最后一行应写为
    echo !str:~%a%,%n%!
当然，要使用!括住变量的前提是开启延迟扩展开关。

【第四章 for循环】
基本格式  for %%variable in (set) do command [command-parameters]
set表示的字符串或变量可以是一个也可以是多个，每一个字符串或变量，我们称为元素，每个元素之间，用
空格键、跳格键、逗号、分号或等号分隔
(1) 循环遍历字符串数组，当前目录下的文件名
    注意到以下代码中，括号内部是一个集合，默认的分隔符是逗号，那么也就是说，将以逗号为分隔符输出每一个元素。上面提及
分隔符还包括空格、tab键、分号、等号。值得注意的是，多余空格符将会被忽略

    for %%i in (aa,bb,cc) do echo %%i

另外，如果不希望这些分隔符起作用，或者就想在分出来的字符串中包含空格逗号等分隔符，那也不难，两边加一个双引号就够了，待到
分离出来之后再去除即可。因为在bat脚本中，无论何时，双引号括起来的东西都只会被当作一个元素，这一点需要多多领悟。

    无参的for循环还可以用来遍历当前文件夹下的文件名，如下

    for %%i in (*.txt) do echo %%i
这段代码将输出当前文件夹下所有以.txt问名字后缀的文件名，注意上述代码只会遍历当前目录下的文件。如果需要遍历文件夹，则加/D的参数即可；
如果还需要以某个文件夹问根目录递归遍历文件或文件夹，则加/R [[drive:]path]参数即可




(2) 循环遍历等差数组，其中A_0表示首项，A_n表示尾项，d表示公差

    for /L %%i in (A_0, d, A_n) do command [command-parameters]

(3) /F 这个是最复杂，同时也是应用最广泛的一个选项。该选项的主要功能是用来遍历指定的文件中的内容。

    for /F %%i in (a.txt) do echo %%i

    以上代码将会输出a.txt文件中的每一行第一个元素，这里未指定分隔符，则默认以空格为分隔符。指定分隔符需在/F后加参数
"delims=xxx"。如下为指定,和=为分隔符

    for /F "delims=,=" %%I in (a.txt) do echo %%i

    还可以通过指定列数来获取不同的列，如"tokens=2,3,4"则依次将第2、3、4列赋值给%%I、%%J、%%K，可以将连续的列用连字符
简写，如上则可写成"tokens=2-4"。另外还可在最后指定星号*，表示将剩余的所有字符赋给下一个变量。如"tokens=1,2,*"则表示把
第一列和第二列分别赋予%%I和%%J，而把一行除了第一列和第二列剩下的部分赋给%%K

    考虑这样一种情况，就是指定的文件是绝对路径，而该路径中又带有空格。如下所示

    for /F "delims== tokens=1,2" %%I in (C:\Program Files\Git\bin\config.ini) do echo %%I %%J

此时，如果直接将该文件的绝对路径写入in后面的括号当中，则势必会发生错误。原因很简单，因为空格是默认分割符，cmd会以为传进了
多个文件，于是会报找不到文件C:\Program的错误。或许有人会想，那我用双引号括住整个路径名不就好了吗。这样也不行，因为这样一
来cmd会认为我们要分析的是一个字符串，于是会把传进来的绝对路径当一行字符串来进行切分处理，这显然不是我们想要的结果。其实
很简单，只需要在/F后面的参数中加上usebackq即可。顺带提一下，usebackq参数除了会让cmd将整个双引号括起来的字符串当成一个文件
来处理外，还有会将in后面()中用反引号``括起来的字符串当成命令来解析，例如一下语句将输出命令dir /b的结果

    for /F "usebackq tokens=*" %%I in (`dir /b`) do echo %%I

    其实真要对命令的执行结果进行处理，不必如此大费周章，只需将命令用单引号括起来即可
    
    for /F %%i in ('dir /b') do echo %%i


(4) 后记

    在for循环的do语句中使用%%I,%%J等变量时，可以用其变形体，如%%~I将去除该字符串中的双引号（如果有的话）。还有其他的
变形体，可以用for /? 查看。


【第五章 函数】
确切来讲，bat脚本的函数与汇编里的函数极其类似，其实只是一个标签，加了一个跳转而已，当然了，既然是函数，那就有相应参数的处理
我们从下面代码开始学习函数的使用。
（1）无参
    call:fun

    :fun
    echo hhh
    goto:eof

这段代码中，我们用fun标签定义了一个函数，该函数内容很简单，就是输出一句hhh，前面的call:fun就是调用此函数，fun函数中的最后一句
goto:eof保证了函数执行完之后能返回到被调用的语句。值得提醒的是，以上代码会输出两行hhh，因为就其本质而言，fun仅仅是一段代码的起始
标签，也就是说执行了call:fun之后，又会接着执行fun标签下的语句。要想阻止此类情况的发生，只需在call:fun语句和fun标签中间加上goto:eof
或exit之类的返回语句即可。
（2）带参
    call:fun2 xxx hhh
    goto:eof

    :fun2
    echo %1
    echo %2
    goto:eof

这段代码的fun2函数在被调用的时候传了两个参数，在fun2函数的实现中分别输出了这两个参数。由此可以看出，函数中对参数的引用是用%n，其中
n取1到9之间的数字。
    有时候我们需要传入一个带文件全路径作为参数，此时路径中可能会包含空格。不难想到，如果直接将路径作为参数调用函数，则将不如我们所愿。
cmd会把这一个参数当作多个参数。于是我们又想到了双引号，没错，是得用双引号来传入。这样，cmd会将它当成一个整体，但是与原来的字符串相比，
传入的字符串两边添加了双引号，如果我们不需要双引号，只需要在引用参数的时候在%和n之间加~，例如%~1，这样得到的字符串就会去除原来为把参数
当作整体而加上的双引号。示例如下
    
    call:fun3 "C:\Program Files\Git\bin"
    goto:eof

    :fun3
    echo %~1

运行该脚本，屏幕将输出C:\Program Files\Git\bin，注意两边没有双引号。如果把下面的echo %~1换成echo %1则会输出"C:\Program Files\Git\bin"

    确切来讲，加双引号并不一定能达到将所传参数不被切分成多个参数目的。比如下面的代码段

    set str="aa bb"
    call:fun4 "%str%"
    goto:eof

    :fun4
    echo %~1
    goto:eof

简单分析不难得出它的输出是""aa，而不是我们一开始所想要的"aa bb"或是""aa bb""。原因在于双引号是从左到右依次匹配的。
    那么，我们如何才能一定保证传入的参数不被当成多个参数呢？答案很简单，用变量先保存想要传的值，然后把变量名直接当参数传入，函数体引用该变量
即可。注意在函数中引用变量必须用!括起来，因为参数的引用已经有了%，外面不能再加了。如下代码示例
    
    setlocal enabledelayedexpansion
    set str="aa bb"
    call:fun5 str
    goto:eof

    :fun5
    echo !%1!
    goto:eof

此时如果还要去除双引号，则将echo !%1!改成echo !%1:"=!即可。
