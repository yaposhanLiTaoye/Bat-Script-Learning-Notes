【第一章  杂项】
输出空行   echo .

echo的开关。echo有两种状态，打开和关闭。这里说的是是否开启回显当前所执行的命令。默认情况下，开关是打开的。
因此我们会在cmd一条语句执行效果之前看到该语句本身，就好像你把语句敲在命令行里一样。如果我们需要关闭这个开关，有两种方式，
一种是全局性的，即在脚本一开始就添加语句@echo off，还有一种是局部性的，即在不需要输出命令本身的echo语句之前加@


【第二章  字符串截取】
%var:~a[,n]%  从第a位往后最多截取n个字符，若不指定参数n则截取到最后一位

【第三章  变量引用与延迟赋值】
    
    set a=hhh
    echo %a%

以上两句，在执行到echo %a%时，首先将%a%替换成hhh，再执行，相当于c语言的宏定义先预编译一遍。这一点在echo打开的状态下可以很清楚的看到。

需要注意的是，bat脚本在执行的时候是一句一句执行的，而一个变量的赋值只有当赋值动作所在的语句结束之后才会生效。
这一机制可能会导致一些初学者疑惑的地方，比如下面代码段

    set /a a=1
    if "abc" == "abc" (
        set /a a=2
        echo Now a = %a%
    )

初学者或许会以为输出是
        Now a = 2
但其实不是，运行结果为
        Now a = 1

这里其实需要注意的是if语句连同后面的括号部分构成的仅仅是一条语句，也就是说执行这一条语句的时候，cmd首先将if 语句中的%a%替换为当前值，
也就是上一条语句起作用之后的值1，因此实际上cmd执行的是
    set /a a=1
    if "abc" == "abc" (
        set /a a=2
        echo Now a = 1
    )
这就解释了为什么输出的结果会是之前的1了。我们可以在if语句后输出一下a，就能看到a的值变成了2，因为整个if语句已经执行完了。

    那如果我们需要获取一条语句中变量当前实际的值，应该怎么办呢？答案很简单，就是在一开始设置延时扩展，即使用语句
        setlocal enabledelayedexpansion
并在后续需要使用即时值的地方用!var!的形式指代。注意，用感叹号括起来的变量只有在开启了延时扩展才是指引用该变量，在没有开启延时扩展的
情况下单纯表示!字符本身。

扩展：结合前一章字符串截取的知识，我们知道截取字符串第a位后的n位可以用%var:~a,n%表示，注意这里需要a,n是数字。那如何将a和n替换成
可以变化的变量以方便我们对字符串进行处理呢？首先我们需要使用宏定义将a,n处的变量替换为相应的数值，再进行截取。也就是说，里面的起始值a
和截取长度n需要用%括起变量表示，比如
    set str=whenIwasyoung
    set a=1
    set n=3
    echo %str:~%a%,%n%%
以上代码是否可行呢？这里我们可以同样在开启echo的情况下看它的执行情况。可以看到在执行到第4句的时候，其实执行的是
    echo whenIwasyoungan%
不难看出，在进行宏替换时，系统首先替换了%str:~%，也就是str所代表的字符串本身；接着是字符a；接着是%,%，由于没这个变量，所以为空；接着
是字符n;最后的%%在字符串表示字符%本身。故此，我们不能用这种形式来达到我们所希望的效果。结合本章所说的延迟变量扩展，不难想到可以用!括起
变量str，即最后一行应写为
    echo !str:~%a%,%n%!
当然，要使用!括住变量的前提是开启延迟扩展开关。
